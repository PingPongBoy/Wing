import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as t,e as n}from"./app-4ef98c74.js";const e={},r=n('<h3 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h3><div class="hint-container info"><p class="hint-container-title">为什么需要分布式事务？</p><p>银行跨行转账业务是一个典型分布式事务场景，假设A需要跨行转账给B，那么就涉及两个银行的数据，无法通过一个数据库的本地事务保证转账的ACID，只能够通过分布式事务来解决。</p></div><p><strong>事务具有 4 个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为 ACID 特性。</strong></p><ul><li><p>Atomicity（原子性）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复到事务开始前的状态，就像这个事务从来没有执行过一样。</p></li><li><p>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。完整性包括外键约束、应用定义的等约束不会被破坏。</p></li><li><p>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</p></li><li><p>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p></li></ul><p><strong>分布式事务的解决方案有Saga、TCC、XA、本地消息表等，Wing目前支持的是Saga模式</strong></p><h3 id="saga相关概念" tabindex="-1"><a class="header-anchor" href="#saga相关概念" aria-hidden="true">#</a> Saga相关概念</h3><div class="hint-container info"><p class="hint-container-title">Saga来源</p><p>1987年普林斯顿大学的Hector Garcia-Molina和Kenneth Salem发表了一篇Paper Sagas，讲述的是如何处理long lived transaction（长活事务）。Saga是一个长活事务可被分解成可以交错运行的子事务集合。其中每个子事务都是一个保持数据库一致性的真实事务。</p></div><ul><li>Saga的组成</li></ul><p>每个Saga由一系列sub-transaction Ti 组成，每个Ti 都有对应的补偿动作Ci，补偿动作用于撤销Ti造成的结果。</p><ul><li>执行顺序</li></ul><p>① T1, T2, T3, ..., Tn</p><p>② T1, T2, ..., Tj, Cj,..., C2, C1，其中0 &lt; j &lt; n</p><ul><li>恢复策略</li></ul><p>① backward recovery，向后恢复，补偿所有已完成的事务，如果任一子事务失败。即上面提到的第二种执行顺序，其中j是发生错误的sub-transaction，这种做法的效果是撤销掉之前所有成功的sub-transation，使得整个Saga的执行结果撤销。</p><p>② forward recovery，向前恢复，重试失败的事务，假设每个子事务最终都会成功。适用于必须要成功的场景，执行顺序是类似于这样的：T1, T2, ..., Tj(失败), Tj(重试),..., Tn，其中j是发生错误的sub-transaction。该情况下不需要Ci。</p><p>显然，向前恢复没有必要提供补偿事务，如果你的业务中，子事务（最终）总会成功，或补偿事务难以定义或不可能，向前恢复更符合你的需求。</p>',16),l=[r];function o(s,c){return i(),t("div",null,l)}const h=a(e,[["render",o],["__file","introduce.html.vue"]]);export{h as default};
